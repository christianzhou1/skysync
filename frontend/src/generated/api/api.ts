/* tslint:disable */
/* eslint-disable */
/**
 * Todo API
 * A comprehensive Todo Management System API with user authentication, task management, and file attachments
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'filename'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'contentType'?: string;
    /**
     * 
     * @type {number}
     * @memberof Attachment
     */
    'sizeBytes'?: number;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'checksumSha256'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'storagePath'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {Array<TaskAttachment>}
     * @memberof Attachment
     */
    'taskAttachments'?: Array<TaskAttachment>;
}
/**
 * 
 * @export
 * @interface AttachmentInfo
 */
export interface AttachmentInfo {
    /**
     * 
     * @type {string}
     * @memberof AttachmentInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentInfo
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentInfo
     */
    'contentType'?: string;
    /**
     * 
     * @type {number}
     * @memberof AttachmentInfo
     */
    'sizeBytes'?: number;
    /**
     * 
     * @type {string}
     * @memberof AttachmentInfo
     */
    'checksumSha256'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentInfo
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentInfo
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttachmentInfo
     */
    'taskId'?: string;
}
/**
 * 
 * @export
 * @interface AuthResponse
 */
export interface AuthResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthResponse
     */
    'expiresAt'?: string;
}
/**
 * 
 * @export
 * @interface CommentInfo
 */
export interface CommentInfo {
    /**
     * 
     * @type {string}
     * @memberof CommentInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentInfo
     */
    'body'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentInfo
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentInfo
     */
    'author'?: string;
}
/**
 * 
 * @export
 * @interface CreateTaskRequest
 */
export interface CreateTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateTaskRequest
     */
    'parentTaskId'?: string;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    'href'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Link
     */
    'templated'?: boolean;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'usernameOrEmail': string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof Task
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'dueDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Task
     */
    'displayOrder'?: number;
    /**
     * 
     * @type {Task}
     * @memberof Task
     */
    'parentTask'?: Task;
    /**
     * 
     * @type {Array<Task>}
     * @memberof Task
     */
    'subtasks'?: Array<Task>;
    /**
     * 
     * @type {Array<TaskAttachment>}
     * @memberof Task
     */
    'taskAttachments'?: Array<TaskAttachment>;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'completed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Task
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface TaskAttachment
 */
export interface TaskAttachment {
    /**
     * 
     * @type {Task}
     * @memberof TaskAttachment
     */
    'task'?: Task;
    /**
     * 
     * @type {Attachment}
     * @memberof TaskAttachment
     */
    'attachment'?: Attachment;
    /**
     * 
     * @type {string}
     * @memberof TaskAttachment
     */
    'createdAt'?: string;
}
/**
 * 
 * @export
 * @interface TaskDetailInfo
 */
export interface TaskDetailInfo {
    /**
     * 
     * @type {string}
     * @memberof TaskDetailInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDetailInfo
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDetailInfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDetailInfo
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskDetailInfo
     */
    'dueDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskDetailInfo
     */
    'overdue'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TaskDetailInfo
     */
    'daysUntilDue'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TaskDetailInfo
     */
    'categories'?: Array<string>;
    /**
     * 
     * @type {Array<CommentInfo>}
     * @memberof TaskDetailInfo
     */
    'comments'?: Array<CommentInfo>;
    /**
     * 
     * @type {Array<AttachmentInfo>}
     * @memberof TaskDetailInfo
     */
    'attachments'?: Array<AttachmentInfo>;
    /**
     * 
     * @type {boolean}
     * @memberof TaskDetailInfo
     */
    'completed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskDetailInfo
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface TaskSummary
 */
export interface TaskSummary {
    /**
     * 
     * @type {string}
     * @memberof TaskSummary
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSummary
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSummary
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSummary
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSummary
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskSummary
     */
    'parentTaskId'?: string;
    /**
     * 
     * @type {Array<TaskSummary>}
     * @memberof TaskSummary
     */
    'subtasks'?: Array<TaskSummary>;
    /**
     * 
     * @type {number}
     * @memberof TaskSummary
     */
    'subtaskCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskSummary
     */
    'attachmentCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TaskSummary
     */
    'completed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskSummary
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateTaskRequest
 */
export interface UpdateTaskRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskRequest
     */
    'dueDate'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateTaskRequest
     */
    'isCompleted'?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'passwordHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    'active'?: boolean;
}
/**
 * 
 * @export
 * @interface UserSummary
 */
export interface UserSummary {
    /**
     * 
     * @type {string}
     * @memberof UserSummary
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSummary
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSummary
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSummary
     */
    'lastName'?: string;
}

/**
 * ActuatorApi - axios parameter creator
 * @export
 */
export const ActuatorApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actuator web endpoint \'info\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Actuator root web endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        links: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/actuator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActuatorApi - functional programming interface
 * @export
 */
export const ActuatorApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ActuatorApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async health(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.health(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.health']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actuator web endpoint \'info\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async info(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.info(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.info']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Actuator root web endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async links(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: Link; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.links(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ActuatorApi.links']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ActuatorApi - factory interface
 * @export
 */
export const ActuatorApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ActuatorApiFp(configuration)
    return {
        /**
         * 
         * @summary Actuator web endpoint \'health\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        health(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.health(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actuator web endpoint \'info\'
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        info(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.info(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Actuator root web endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        links(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: { [key: string]: Link; }; }> {
            return localVarFp.links(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActuatorApi - interface
 * @export
 * @interface ActuatorApi
 */
export interface ActuatorApiInterface {
    /**
     * 
     * @summary Actuator web endpoint \'health\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApiInterface
     */
    health(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Actuator web endpoint \'info\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApiInterface
     */
    info(options?: RawAxiosRequestConfig): AxiosPromise<object>;

    /**
     * 
     * @summary Actuator root web endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApiInterface
     */
    links(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: { [key: string]: Link; }; }>;

}

/**
 * ActuatorApi - object-oriented interface
 * @export
 * @class ActuatorApi
 * @extends {BaseAPI}
 */
export class ActuatorApi extends BaseAPI implements ActuatorApiInterface {
    /**
     * 
     * @summary Actuator web endpoint \'health\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public health(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).health(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actuator web endpoint \'info\'
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public info(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).info(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Actuator root web endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActuatorApi
     */
    public links(options?: RawAxiosRequestConfig) {
        return ActuatorApiFp(this.configuration).links(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information about the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate user and return JWT token
         * @summary User login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout user (client-side token removal)
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Get information about the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate user and return JWT token
         * @summary User login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout user (client-side token removal)
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logout']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Get information about the currently authenticated user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate user and return JWT token
         * @summary User login
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse> {
            return localVarFp.login(loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout user (client-side token removal)
         * @summary User logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * Get information about the currently authenticated user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse>;

    /**
     * Authenticate user and return JWT token
     * @summary User login
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthResponse>;

    /**
     * Logout user (client-side token removal)
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    logout(options?: RawAxiosRequestConfig): AxiosPromise<void>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * Get information about the currently authenticated user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate user and return JWT token
     * @summary User login
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).login(loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout user (client-side token removal)
     * @summary User logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logout(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DebugControllerApi - axios parameter creator
 * @export
 */
export const DebugControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAuth: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/debug/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugPublic: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/debug/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DebugControllerApi - functional programming interface
 * @export
 */
export const DebugControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DebugControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugAuth(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugAuth(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DebugControllerApi.debugAuth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async debugPublic(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.debugPublic(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DebugControllerApi.debugPublic']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DebugControllerApi - factory interface
 * @export
 */
export const DebugControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DebugControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugAuth(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.debugAuth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        debugPublic(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.debugPublic(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DebugControllerApi - interface
 * @export
 * @interface DebugControllerApi
 */
export interface DebugControllerApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebugControllerApiInterface
     */
    debugAuth(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebugControllerApiInterface
     */
    debugPublic(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }>;

}

/**
 * DebugControllerApi - object-oriented interface
 * @export
 * @class DebugControllerApi
 * @extends {BaseAPI}
 */
export class DebugControllerApi extends BaseAPI implements DebugControllerApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebugControllerApi
     */
    public debugAuth(options?: RawAxiosRequestConfig) {
        return DebugControllerApiFp(this.configuration).debugAuth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DebugControllerApi
     */
    public debugPublic(options?: RawAxiosRequestConfig) {
        return DebugControllerApiFp(this.configuration).debugPublic(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EnvironmentControllerApi - axios parameter creator
 * @export
 */
export const EnvironmentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/environment/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentControllerApi - functional programming interface
 * @export
 */
export const EnvironmentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EnvironmentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEnvironmentInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEnvironmentInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EnvironmentControllerApi.getEnvironmentInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EnvironmentControllerApi - factory interface
 * @export
 */
export const EnvironmentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EnvironmentControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnvironmentInfo(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getEnvironmentInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EnvironmentControllerApi - interface
 * @export
 * @interface EnvironmentControllerApi
 */
export interface EnvironmentControllerApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentControllerApiInterface
     */
    getEnvironmentInfo(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }>;

}

/**
 * EnvironmentControllerApi - object-oriented interface
 * @export
 * @class EnvironmentControllerApi
 * @extends {BaseAPI}
 */
export class EnvironmentControllerApi extends BaseAPI implements EnvironmentControllerApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentControllerApi
     */
    public getEnvironmentInfo(options?: RawAxiosRequestConfig) {
        return EnvironmentControllerApiFp(this.configuration).getEnvironmentInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FileAttachmentsApi - axios parameter creator
 * @export
 */
export const FileAttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete attachment metadata and underlying file
         * @summary Delete attachment
         * @param {string} id Attachment ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('_delete', 'xUserId', xUserId)
            const localVarPath = `/attachments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach an existing unlinked file to a task
         * @summary Attach file to task
         * @param {string} id Attachment ID
         * @param {string} taskId Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attach: async (id: string, taskId: string, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('attach', 'id', id)
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('attach', 'taskId', taskId)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('attach', 'xUserId', xUserId)
            const localVarPath = `/attachments/{id}/attach/{taskId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach a file from its task (keeps file and metadata)
         * @summary Detach file from task
         * @param {string} id Attachment ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detach: async (id: string, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('detach', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('detach', 'xUserId', xUserId)
            const localVarPath = `/attachments/{id}/detach`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a file attachment
         * @summary Download file
         * @param {string} id Attachment ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download: async (id: string, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('download', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('download', 'xUserId', xUserId)
            const localVarPath = `/attachments/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all attachments for a specific task
         * @summary List task attachments
         * @param {string} taskId Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForTask: async (taskId: string, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('listForTask', 'taskId', taskId)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('listForTask', 'xUserId', xUserId)
            const localVarPath = `/attachments/task/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all attachments for the current user
         * @summary List user attachments
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForUser: async (xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('listForUser', 'xUserId', xUserId)
            const localVarPath = `/attachments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file without linking it to a specific task
         * @summary Upload file
         * @param {string} xUserId 
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload: async (xUserId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('upload', 'xUserId', xUserId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('upload', 'file', file)
            const localVarPath = `/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a file and attach it to a specific task
         * @summary Upload file for task
         * @param {string} taskId Task ID
         * @param {string} xUserId 
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadForTask: async (taskId: string, xUserId: string, file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('uploadForTask', 'taskId', taskId)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('uploadForTask', 'xUserId', xUserId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadForTask', 'file', file)
            const localVarPath = `/attachments/task/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileAttachmentsApi - functional programming interface
 * @export
 */
export const FileAttachmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileAttachmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete attachment metadata and underlying file
         * @summary Delete attachment
         * @param {string} id Attachment ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileAttachmentsApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Attach an existing unlinked file to a task
         * @summary Attach file to task
         * @param {string} id Attachment ID
         * @param {string} taskId Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attach(id: string, taskId: string, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.attach(id, taskId, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileAttachmentsApi.attach']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Detach a file from its task (keeps file and metadata)
         * @summary Detach file from task
         * @param {string} id Attachment ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detach(id: string, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.detach(id, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileAttachmentsApi.detach']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download a file attachment
         * @summary Download file
         * @param {string} id Attachment ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async download(id: string, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.download(id, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileAttachmentsApi.download']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all attachments for a specific task
         * @summary List task attachments
         * @param {string} taskId Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForTask(taskId: string, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttachmentInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForTask(taskId, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileAttachmentsApi.listForTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all attachments for the current user
         * @summary List user attachments
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForUser(xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AttachmentInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForUser(xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileAttachmentsApi.listForUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a file without linking it to a specific task
         * @summary Upload file
         * @param {string} xUserId 
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async upload(xUserId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.upload(xUserId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileAttachmentsApi.upload']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a file and attach it to a specific task
         * @summary Upload file for task
         * @param {string} taskId Task ID
         * @param {string} xUserId 
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadForTask(taskId: string, xUserId: string, file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AttachmentInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadForTask(taskId, xUserId, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FileAttachmentsApi.uploadForTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FileAttachmentsApi - factory interface
 * @export
 */
export const FileAttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileAttachmentsApiFp(configuration)
    return {
        /**
         * Delete attachment metadata and underlying file
         * @summary Delete attachment
         * @param {string} id Attachment ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._delete(id, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach an existing unlinked file to a task
         * @summary Attach file to task
         * @param {string} id Attachment ID
         * @param {string} taskId Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attach(id: string, taskId: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentInfo> {
            return localVarFp.attach(id, taskId, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach a file from its task (keeps file and metadata)
         * @summary Detach file from task
         * @param {string} id Attachment ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detach(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentInfo> {
            return localVarFp.detach(id, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a file attachment
         * @summary Download file
         * @param {string} id Attachment ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        download(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.download(id, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all attachments for a specific task
         * @summary List task attachments
         * @param {string} taskId Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForTask(taskId: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AttachmentInfo>> {
            return localVarFp.listForTask(taskId, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all attachments for the current user
         * @summary List user attachments
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForUser(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AttachmentInfo>> {
            return localVarFp.listForUser(xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a file without linking it to a specific task
         * @summary Upload file
         * @param {string} xUserId 
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        upload(xUserId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentInfo> {
            return localVarFp.upload(xUserId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a file and attach it to a specific task
         * @summary Upload file for task
         * @param {string} taskId Task ID
         * @param {string} xUserId 
         * @param {File} file File to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadForTask(taskId: string, xUserId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentInfo> {
            return localVarFp.uploadForTask(taskId, xUserId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileAttachmentsApi - interface
 * @export
 * @interface FileAttachmentsApi
 */
export interface FileAttachmentsApiInterface {
    /**
     * Delete attachment metadata and underlying file
     * @summary Delete attachment
     * @param {string} id Attachment ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApiInterface
     */
    _delete(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Attach an existing unlinked file to a task
     * @summary Attach file to task
     * @param {string} id Attachment ID
     * @param {string} taskId Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApiInterface
     */
    attach(id: string, taskId: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentInfo>;

    /**
     * Detach a file from its task (keeps file and metadata)
     * @summary Detach file from task
     * @param {string} id Attachment ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApiInterface
     */
    detach(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentInfo>;

    /**
     * Download a file attachment
     * @summary Download file
     * @param {string} id Attachment ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApiInterface
     */
    download(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Get all attachments for a specific task
     * @summary List task attachments
     * @param {string} taskId Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApiInterface
     */
    listForTask(taskId: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AttachmentInfo>>;

    /**
     * Get all attachments for the current user
     * @summary List user attachments
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApiInterface
     */
    listForUser(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<AttachmentInfo>>;

    /**
     * Upload a file without linking it to a specific task
     * @summary Upload file
     * @param {string} xUserId 
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApiInterface
     */
    upload(xUserId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentInfo>;

    /**
     * Upload a file and attach it to a specific task
     * @summary Upload file for task
     * @param {string} taskId Task ID
     * @param {string} xUserId 
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApiInterface
     */
    uploadForTask(taskId: string, xUserId: string, file: File, options?: RawAxiosRequestConfig): AxiosPromise<AttachmentInfo>;

}

/**
 * FileAttachmentsApi - object-oriented interface
 * @export
 * @class FileAttachmentsApi
 * @extends {BaseAPI}
 */
export class FileAttachmentsApi extends BaseAPI implements FileAttachmentsApiInterface {
    /**
     * Delete attachment metadata and underlying file
     * @summary Delete attachment
     * @param {string} id Attachment ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public _delete(id: string, xUserId: string, options?: RawAxiosRequestConfig) {
        return FileAttachmentsApiFp(this.configuration)._delete(id, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Attach an existing unlinked file to a task
     * @summary Attach file to task
     * @param {string} id Attachment ID
     * @param {string} taskId Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public attach(id: string, taskId: string, xUserId: string, options?: RawAxiosRequestConfig) {
        return FileAttachmentsApiFp(this.configuration).attach(id, taskId, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Detach a file from its task (keeps file and metadata)
     * @summary Detach file from task
     * @param {string} id Attachment ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public detach(id: string, xUserId: string, options?: RawAxiosRequestConfig) {
        return FileAttachmentsApiFp(this.configuration).detach(id, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a file attachment
     * @summary Download file
     * @param {string} id Attachment ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public download(id: string, xUserId: string, options?: RawAxiosRequestConfig) {
        return FileAttachmentsApiFp(this.configuration).download(id, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all attachments for a specific task
     * @summary List task attachments
     * @param {string} taskId Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public listForTask(taskId: string, xUserId: string, options?: RawAxiosRequestConfig) {
        return FileAttachmentsApiFp(this.configuration).listForTask(taskId, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all attachments for the current user
     * @summary List user attachments
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public listForUser(xUserId: string, options?: RawAxiosRequestConfig) {
        return FileAttachmentsApiFp(this.configuration).listForUser(xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a file without linking it to a specific task
     * @summary Upload file
     * @param {string} xUserId 
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public upload(xUserId: string, file: File, options?: RawAxiosRequestConfig) {
        return FileAttachmentsApiFp(this.configuration).upload(xUserId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a file and attach it to a specific task
     * @summary Upload file for task
     * @param {string} taskId Task ID
     * @param {string} xUserId 
     * @param {File} file File to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileAttachmentsApi
     */
    public uploadForTask(taskId: string, xUserId: string, file: File, options?: RawAxiosRequestConfig) {
        return FileAttachmentsApiFp(this.configuration).uploadForTask(taskId, xUserId, file, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HelloControllerApi - axios parameter creator
 * @export
 */
export const HelloControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hello: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/hello`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelloControllerApi - functional programming interface
 * @export
 */
export const HelloControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HelloControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hello(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hello(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HelloControllerApi.hello']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HelloControllerApi - factory interface
 * @export
 */
export const HelloControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HelloControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hello(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.hello(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HelloControllerApi - interface
 * @export
 * @interface HelloControllerApi
 */
export interface HelloControllerApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelloControllerApiInterface
     */
    hello(options?: RawAxiosRequestConfig): AxiosPromise<string>;

}

/**
 * HelloControllerApi - object-oriented interface
 * @export
 * @class HelloControllerApi
 * @extends {BaseAPI}
 */
export class HelloControllerApi extends BaseAPI implements HelloControllerApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelloControllerApi
     */
    public hello(options?: RawAxiosRequestConfig) {
        return HelloControllerApiFp(this.configuration).hello(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TaskManagementApi - axios parameter creator
 * @export
 */
export const TaskManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new todo task or subtask
         * @summary Create new task
         * @param {string} xUserId 
         * @param {CreateTaskRequest} createTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (xUserId: string, createTaskRequest: CreateTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('createTask', 'xUserId', xUserId)
            // verify required parameter 'createTaskRequest' is not null or undefined
            assertParamExists('createTask', 'createTaskRequest', createTaskRequest)
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Soft delete a task (marks as deleted but preserves data)
         * @summary Delete task
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask: async (id: string, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTask', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('deleteTask', 'xUserId', xUserId)
            const localVarPath = `/tasks/id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all root tasks (tasks without parent tasks)
         * @summary Get root tasks
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootTasks: async (xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('getRootTasks', 'xUserId', xUserId)
            const localVarPath = `/tasks/root`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all direct subtasks of a specific task
         * @summary Get direct subtasks of a task
         * @param {string} id Parent task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtasks: async (id: string, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubtasks', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('getSubtasks', 'xUserId', xUserId)
            const localVarPath = `/tasks/id/{id}/subtasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all subtasks of a task up to a specified depth
         * @summary Get all subtasks recursively
         * @param {string} id Parent task ID
         * @param {string} xUserId 
         * @param {number} [maxDepth] Maximum depth to traverse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtasksRecursively: async (id: string, xUserId: string, maxDepth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubtasksRecursively', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('getSubtasksRecursively', 'xUserId', xUserId)
            const localVarPath = `/tasks/id/{id}/subtasks/recursive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)

            if (maxDepth !== undefined) {
                localVarQueryParameter['maxDepth'] = maxDepth;
            }


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve basic task information by ID
         * @summary Get task by ID
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById: async (id: string, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskById', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('getTaskById', 'xUserId', xUserId)
            const localVarPath = `/tasks/id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information about a specific task including attachments
         * @summary Get task detail by ID
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDetail: async (id: string, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskDetail', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('getTaskDetail', 'xUserId', xUserId)
            const localVarPath = `/tasks/id/{id}/detail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a task with its subtasks organized in a hierarchical structure
         * @summary Get task with subtasks
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {number} [maxDepth] Maximum depth to traverse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskWithSubtasks: async (id: string, xUserId: string, maxDepth?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskWithSubtasks', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('getTaskWithSubtasks', 'xUserId', xUserId)
            const localVarPath = `/tasks/id/{id}/with-subtasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)

            if (maxDepth !== undefined) {
                localVarQueryParameter['maxDepth'] = maxDepth;
            }


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a sample task for testing purposes
         * @summary Create mock task
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertMock: async (xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('insertMock', 'xUserId', xUserId)
            const localVarPath = `/tasks/mock`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a sample task for testing purposes
         * @summary Create mock task
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertMock1: async (xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('insertMock1', 'xUserId', xUserId)
            const localVarPath = `/tasks/mock/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve detailed information for all tasks including attachments
         * @summary Get all task details
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTaskDetails: async (xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('listAllTaskDetails', 'xUserId', xUserId)
            const localVarPath = `/tasks/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all tasks including deleted ones
         * @summary Get all tasks
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTasks: async (xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('listAllTasks', 'xUserId', xUserId)
            const localVarPath = `/tasks/listalltasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of tasks with sorting options
         * @summary Get list of tasks
         * @param {string} xUserId 
         * @param {number} [page] Page number (0-based)
         * @param {number} [size] Page size
         * @param {string} [sort] Sort criteria (e.g., \&#39;createdAt,desc\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks: async (xUserId: string, page?: number, size?: number, sort?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('listTasks', 'xUserId', xUserId)
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sort !== undefined) {
                localVarQueryParameter['sort'] = sort;
            }


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the display order of a task within its hierarchy level
         * @summary Reorder task
         * @param {string} id 
         * @param {number} newDisplayOrder 
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderTask: async (id: string, newDisplayOrder: number, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('reorderTask', 'id', id)
            // verify required parameter 'newDisplayOrder' is not null or undefined
            assertParamExists('reorderTask', 'newDisplayOrder', newDisplayOrder)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('reorderTask', 'xUserId', xUserId)
            const localVarPath = `/tasks/{id}/reorder`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)

            if (newDisplayOrder !== undefined) {
                localVarQueryParameter['newDisplayOrder'] = newDisplayOrder;
            }


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark a task as completed or incomplete
         * @summary Set task completion status
         * @param {string} id Task ID
         * @param {boolean} value Completion status
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompleted: async (id: string, value: boolean, xUserId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('setCompleted', 'id', id)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('setCompleted', 'value', value)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('setCompleted', 'xUserId', xUserId)
            const localVarPath = `/tasks/id/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }


    
            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an existing task (only non-null fields will be updated)
         * @summary Update task
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {UpdateTaskRequest} updateTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask: async (id: string, xUserId: string, updateTaskRequest: UpdateTaskRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateTask', 'id', id)
            // verify required parameter 'xUserId' is not null or undefined
            assertParamExists('updateTask', 'xUserId', xUserId)
            // verify required parameter 'updateTaskRequest' is not null or undefined
            assertParamExists('updateTask', 'updateTaskRequest', updateTaskRequest)
            const localVarPath = `/tasks/id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication XUserIdHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-User-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (xUserId != null) {
                localVarHeaderParameter['X-User-Id'] = String(xUserId);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskManagementApi - functional programming interface
 * @export
 */
export const TaskManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaskManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new todo task or subtask
         * @summary Create new task
         * @param {string} xUserId 
         * @param {CreateTaskRequest} createTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(xUserId: string, createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(xUserId, createTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.createTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Soft delete a task (marks as deleted but preserves data)
         * @summary Delete task
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTask(id: string, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTask(id, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.deleteTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all root tasks (tasks without parent tasks)
         * @summary Get root tasks
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRootTasks(xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRootTasks(xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.getRootTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all direct subtasks of a specific task
         * @summary Get direct subtasks of a task
         * @param {string} id Parent task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtasks(id: string, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubtasks(id, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.getSubtasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all subtasks of a task up to a specified depth
         * @summary Get all subtasks recursively
         * @param {string} id Parent task ID
         * @param {string} xUserId 
         * @param {number} [maxDepth] Maximum depth to traverse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubtasksRecursively(id: string, xUserId: string, maxDepth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubtasksRecursively(id, xUserId, maxDepth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.getSubtasksRecursively']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve basic task information by ID
         * @summary Get task by ID
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskById(id: string, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskById(id, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.getTaskById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information about a specific task including attachments
         * @summary Get task detail by ID
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskDetail(id: string, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskDetailInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskDetail(id, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.getTaskDetail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a task with its subtasks organized in a hierarchical structure
         * @summary Get task with subtasks
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {number} [maxDepth] Maximum depth to traverse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskWithSubtasks(id: string, xUserId: string, maxDepth?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskWithSubtasks(id, xUserId, maxDepth, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.getTaskWithSubtasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a sample task for testing purposes
         * @summary Create mock task
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertMock(xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertMock(xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.insertMock']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a sample task for testing purposes
         * @summary Create mock task
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insertMock1(xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insertMock1(xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.insertMock1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve detailed information for all tasks including attachments
         * @summary Get all task details
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTaskDetails(xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskDetailInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTaskDetails(xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.listAllTaskDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all tasks including deleted ones
         * @summary Get all tasks
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllTasks(xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllTasks(xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.listAllTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of tasks with sorting options
         * @summary Get list of tasks
         * @param {string} xUserId 
         * @param {number} [page] Page number (0-based)
         * @param {number} [size] Page size
         * @param {string} [sort] Sort criteria (e.g., \&#39;createdAt,desc\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTasks(xUserId: string, page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTasks(xUserId, page, size, sort, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.listTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Change the display order of a task within its hierarchy level
         * @summary Reorder task
         * @param {string} id 
         * @param {number} newDisplayOrder 
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reorderTask(id: string, newDisplayOrder: number, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reorderTask(id, newDisplayOrder, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.reorderTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Mark a task as completed or incomplete
         * @summary Set task completion status
         * @param {string} id Task ID
         * @param {boolean} value Completion status
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCompleted(id: string, value: boolean, xUserId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCompleted(id, value, xUserId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.setCompleted']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing task (only non-null fields will be updated)
         * @summary Update task
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {UpdateTaskRequest} updateTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTask(id: string, xUserId: string, updateTaskRequest: UpdateTaskRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTask(id, xUserId, updateTaskRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TaskManagementApi.updateTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TaskManagementApi - factory interface
 * @export
 */
export const TaskManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaskManagementApiFp(configuration)
    return {
        /**
         * Create a new todo task or subtask
         * @summary Create new task
         * @param {string} xUserId 
         * @param {CreateTaskRequest} createTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(xUserId: string, createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary> {
            return localVarFp.createTask(xUserId, createTaskRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Soft delete a task (marks as deleted but preserves data)
         * @summary Delete task
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteTask(id, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all root tasks (tasks without parent tasks)
         * @summary Get root tasks
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRootTasks(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>> {
            return localVarFp.getRootTasks(xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all direct subtasks of a specific task
         * @summary Get direct subtasks of a task
         * @param {string} id Parent task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtasks(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>> {
            return localVarFp.getSubtasks(id, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all subtasks of a task up to a specified depth
         * @summary Get all subtasks recursively
         * @param {string} id Parent task ID
         * @param {string} xUserId 
         * @param {number} [maxDepth] Maximum depth to traverse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubtasksRecursively(id: string, xUserId: string, maxDepth?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>> {
            return localVarFp.getSubtasksRecursively(id, xUserId, maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve basic task information by ID
         * @summary Get task by ID
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary> {
            return localVarFp.getTaskById(id, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information about a specific task including attachments
         * @summary Get task detail by ID
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDetail(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskDetailInfo> {
            return localVarFp.getTaskDetail(id, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a task with its subtasks organized in a hierarchical structure
         * @summary Get task with subtasks
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {number} [maxDepth] Maximum depth to traverse
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskWithSubtasks(id: string, xUserId: string, maxDepth?: number, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary> {
            return localVarFp.getTaskWithSubtasks(id, xUserId, maxDepth, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a sample task for testing purposes
         * @summary Create mock task
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertMock(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary> {
            return localVarFp.insertMock(xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a sample task for testing purposes
         * @summary Create mock task
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertMock1(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary> {
            return localVarFp.insertMock1(xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve detailed information for all tasks including attachments
         * @summary Get all task details
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTaskDetails(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskDetailInfo>> {
            return localVarFp.listAllTaskDetails(xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all tasks including deleted ones
         * @summary Get all tasks
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllTasks(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>> {
            return localVarFp.listAllTasks(xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of tasks with sorting options
         * @summary Get list of tasks
         * @param {string} xUserId 
         * @param {number} [page] Page number (0-based)
         * @param {number} [size] Page size
         * @param {string} [sort] Sort criteria (e.g., \&#39;createdAt,desc\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTasks(xUserId: string, page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>> {
            return localVarFp.listTasks(xUserId, page, size, sort, options).then((request) => request(axios, basePath));
        },
        /**
         * Change the display order of a task within its hierarchy level
         * @summary Reorder task
         * @param {string} id 
         * @param {number} newDisplayOrder 
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reorderTask(id: string, newDisplayOrder: number, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.reorderTask(id, newDisplayOrder, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Mark a task as completed or incomplete
         * @summary Set task completion status
         * @param {string} id Task ID
         * @param {boolean} value Completion status
         * @param {string} xUserId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCompleted(id: string, value: boolean, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary> {
            return localVarFp.setCompleted(id, value, xUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing task (only non-null fields will be updated)
         * @summary Update task
         * @param {string} id Task ID
         * @param {string} xUserId 
         * @param {UpdateTaskRequest} updateTaskRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: string, xUserId: string, updateTaskRequest: UpdateTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary> {
            return localVarFp.updateTask(id, xUserId, updateTaskRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaskManagementApi - interface
 * @export
 * @interface TaskManagementApi
 */
export interface TaskManagementApiInterface {
    /**
     * Create a new todo task or subtask
     * @summary Create new task
     * @param {string} xUserId 
     * @param {CreateTaskRequest} createTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    createTask(xUserId: string, createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary>;

    /**
     * Soft delete a task (marks as deleted but preserves data)
     * @summary Delete task
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    deleteTask(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve all root tasks (tasks without parent tasks)
     * @summary Get root tasks
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    getRootTasks(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>>;

    /**
     * Retrieve all direct subtasks of a specific task
     * @summary Get direct subtasks of a task
     * @param {string} id Parent task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    getSubtasks(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>>;

    /**
     * Retrieve all subtasks of a task up to a specified depth
     * @summary Get all subtasks recursively
     * @param {string} id Parent task ID
     * @param {string} xUserId 
     * @param {number} [maxDepth] Maximum depth to traverse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    getSubtasksRecursively(id: string, xUserId: string, maxDepth?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>>;

    /**
     * Retrieve basic task information by ID
     * @summary Get task by ID
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    getTaskById(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary>;

    /**
     * Retrieve detailed information about a specific task including attachments
     * @summary Get task detail by ID
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    getTaskDetail(id: string, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskDetailInfo>;

    /**
     * Retrieve a task with its subtasks organized in a hierarchical structure
     * @summary Get task with subtasks
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {number} [maxDepth] Maximum depth to traverse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    getTaskWithSubtasks(id: string, xUserId: string, maxDepth?: number, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary>;

    /**
     * Create a sample task for testing purposes
     * @summary Create mock task
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    insertMock(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary>;

    /**
     * Create a sample task for testing purposes
     * @summary Create mock task
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    insertMock1(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary>;

    /**
     * Retrieve detailed information for all tasks including attachments
     * @summary Get all task details
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    listAllTaskDetails(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskDetailInfo>>;

    /**
     * Retrieve all tasks including deleted ones
     * @summary Get all tasks
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    listAllTasks(xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>>;

    /**
     * Retrieve a list of tasks with sorting options
     * @summary Get list of tasks
     * @param {string} xUserId 
     * @param {number} [page] Page number (0-based)
     * @param {number} [size] Page size
     * @param {string} [sort] Sort criteria (e.g., \&#39;createdAt,desc\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    listTasks(xUserId: string, page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>>;

    /**
     * Change the display order of a task within its hierarchy level
     * @summary Reorder task
     * @param {string} id 
     * @param {number} newDisplayOrder 
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    reorderTask(id: string, newDisplayOrder: number, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<Task>;

    /**
     * Mark a task as completed or incomplete
     * @summary Set task completion status
     * @param {string} id Task ID
     * @param {boolean} value Completion status
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    setCompleted(id: string, value: boolean, xUserId: string, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary>;

    /**
     * Update an existing task (only non-null fields will be updated)
     * @summary Update task
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {UpdateTaskRequest} updateTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApiInterface
     */
    updateTask(id: string, xUserId: string, updateTaskRequest: UpdateTaskRequest, options?: RawAxiosRequestConfig): AxiosPromise<TaskSummary>;

}

/**
 * TaskManagementApi - object-oriented interface
 * @export
 * @class TaskManagementApi
 * @extends {BaseAPI}
 */
export class TaskManagementApi extends BaseAPI implements TaskManagementApiInterface {
    /**
     * Create a new todo task or subtask
     * @summary Create new task
     * @param {string} xUserId 
     * @param {CreateTaskRequest} createTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public createTask(xUserId: string, createTaskRequest: CreateTaskRequest, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).createTask(xUserId, createTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Soft delete a task (marks as deleted but preserves data)
     * @summary Delete task
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public deleteTask(id: string, xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).deleteTask(id, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all root tasks (tasks without parent tasks)
     * @summary Get root tasks
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public getRootTasks(xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).getRootTasks(xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all direct subtasks of a specific task
     * @summary Get direct subtasks of a task
     * @param {string} id Parent task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public getSubtasks(id: string, xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).getSubtasks(id, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all subtasks of a task up to a specified depth
     * @summary Get all subtasks recursively
     * @param {string} id Parent task ID
     * @param {string} xUserId 
     * @param {number} [maxDepth] Maximum depth to traverse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public getSubtasksRecursively(id: string, xUserId: string, maxDepth?: number, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).getSubtasksRecursively(id, xUserId, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve basic task information by ID
     * @summary Get task by ID
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public getTaskById(id: string, xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).getTaskById(id, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information about a specific task including attachments
     * @summary Get task detail by ID
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public getTaskDetail(id: string, xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).getTaskDetail(id, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a task with its subtasks organized in a hierarchical structure
     * @summary Get task with subtasks
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {number} [maxDepth] Maximum depth to traverse
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public getTaskWithSubtasks(id: string, xUserId: string, maxDepth?: number, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).getTaskWithSubtasks(id, xUserId, maxDepth, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a sample task for testing purposes
     * @summary Create mock task
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public insertMock(xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).insertMock(xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a sample task for testing purposes
     * @summary Create mock task
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public insertMock1(xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).insertMock1(xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve detailed information for all tasks including attachments
     * @summary Get all task details
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public listAllTaskDetails(xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).listAllTaskDetails(xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all tasks including deleted ones
     * @summary Get all tasks
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public listAllTasks(xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).listAllTasks(xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of tasks with sorting options
     * @summary Get list of tasks
     * @param {string} xUserId 
     * @param {number} [page] Page number (0-based)
     * @param {number} [size] Page size
     * @param {string} [sort] Sort criteria (e.g., \&#39;createdAt,desc\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public listTasks(xUserId: string, page?: number, size?: number, sort?: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).listTasks(xUserId, page, size, sort, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change the display order of a task within its hierarchy level
     * @summary Reorder task
     * @param {string} id 
     * @param {number} newDisplayOrder 
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public reorderTask(id: string, newDisplayOrder: number, xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).reorderTask(id, newDisplayOrder, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark a task as completed or incomplete
     * @summary Set task completion status
     * @param {string} id Task ID
     * @param {boolean} value Completion status
     * @param {string} xUserId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public setCompleted(id: string, value: boolean, xUserId: string, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).setCompleted(id, value, xUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an existing task (only non-null fields will be updated)
     * @summary Update task
     * @param {string} id Task ID
     * @param {string} xUserId 
     * @param {UpdateTaskRequest} updateTaskRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskManagementApi
     */
    public updateTask(id: string, xUserId: string, updateTaskRequest: UpdateTaskRequest, options?: RawAxiosRequestConfig) {
        return TaskManagementApiFp(this.configuration).updateTask(id, xUserId, updateTaskRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserManagementApi - axios parameter creator
 * @export
 */
export const UserManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a user account
         * @summary Activate user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('activateUser', 'id', id)
            const localVarPath = `/users/id/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new user account
         * @summary Create new user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (createUserRequest: CreateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserRequest' is not null or undefined
            assertParamExists('createUser', 'createUserRequest', createUserRequest)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate a user account
         * @summary Deactivate user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateUser', 'id', id)
            const localVarPath = `/users/id/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of all users in the system
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/get-all-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user information by user ID
         * @summary Get user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/users/id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve user information by username
         * @summary Get user by username
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (username: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByUsername', 'username', username)
            const localVarPath = `/users/username/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all tasks for a specific user
         * @summary Get user tasks
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTasks: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserTasks', 'id', id)
            const localVarPath = `/users/id/{id}/tasks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user information
         * @summary Update user
         * @param {string} id User ID
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (id: string, updateUserRequest: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUser', 'id', id)
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('updateUser', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/users/id/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserManagementApi - functional programming interface
 * @export
 */
export const UserManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Activate a user account
         * @summary Activate user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.activateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new user account
         * @summary Create new user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(createUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.createUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate a user account
         * @summary Deactivate user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.deactivateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a list of all users in the system
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve user information by user ID
         * @summary Get user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve user information by username
         * @summary Get user by username
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(username: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(username, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getUserByUsername']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all tasks for a specific user
         * @summary Get user tasks
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTasks(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaskSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTasks(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.getUserTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user information
         * @summary Update user
         * @param {string} id User ID
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(id, updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserManagementApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserManagementApi - factory interface
 * @export
 */
export const UserManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserManagementApiFp(configuration)
    return {
        /**
         * Activate a user account
         * @summary Activate user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.activateUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user account
         * @summary Create new user
         * @param {CreateUserRequest} createUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.createUser(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate a user account
         * @summary Deactivate user
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deactivateUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of all users in the system
         * @summary Get all users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSummary>> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve user information by user ID
         * @summary Get user by ID
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.getUserById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve user information by username
         * @summary Get user by username
         * @param {string} username Username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.getUserByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all tasks for a specific user
         * @summary Get user tasks
         * @param {string} id User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTasks(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>> {
            return localVarFp.getUserTasks(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user information
         * @summary Update user
         * @param {string} id User ID
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo> {
            return localVarFp.updateUser(id, updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserManagementApi - interface
 * @export
 * @interface UserManagementApi
 */
export interface UserManagementApiInterface {
    /**
     * Activate a user account
     * @summary Activate user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApiInterface
     */
    activateUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Create a new user account
     * @summary Create new user
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApiInterface
     */
    createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo>;

    /**
     * Deactivate a user account
     * @summary Deactivate user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApiInterface
     */
    deactivateUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

    /**
     * Retrieve a list of all users in the system
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApiInterface
     */
    getAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSummary>>;

    /**
     * Retrieve user information by user ID
     * @summary Get user by ID
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApiInterface
     */
    getUserById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo>;

    /**
     * Retrieve user information by username
     * @summary Get user by username
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApiInterface
     */
    getUserByUsername(username: string, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo>;

    /**
     * Retrieve all tasks for a specific user
     * @summary Get user tasks
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApiInterface
     */
    getUserTasks(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<TaskSummary>>;

    /**
     * Update user information
     * @summary Update user
     * @param {string} id User ID
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApiInterface
     */
    updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserInfo>;

}

/**
 * UserManagementApi - object-oriented interface
 * @export
 * @class UserManagementApi
 * @extends {BaseAPI}
 */
export class UserManagementApi extends BaseAPI implements UserManagementApiInterface {
    /**
     * Activate a user account
     * @summary Activate user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public activateUser(id: string, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).activateUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new user account
     * @summary Create new user
     * @param {CreateUserRequest} createUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public createUser(createUserRequest: CreateUserRequest, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).createUser(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate a user account
     * @summary Deactivate user
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public deactivateUser(id: string, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).deactivateUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of all users in the system
     * @summary Get all users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getAllUsers(options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve user information by user ID
     * @summary Get user by ID
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getUserById(id: string, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getUserById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve user information by username
     * @summary Get user by username
     * @param {string} username Username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getUserByUsername(username: string, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getUserByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all tasks for a specific user
     * @summary Get user tasks
     * @param {string} id User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public getUserTasks(id: string, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).getUserTasks(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user information
     * @summary Update user
     * @param {string} id User ID
     * @param {UpdateUserRequest} updateUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserManagementApi
     */
    public updateUser(id: string, updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserManagementApiFp(this.configuration).updateUser(id, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



